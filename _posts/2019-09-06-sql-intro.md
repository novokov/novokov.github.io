---
title: Интро в mySQL
categories:
  - sql
---



! ```$ mysql -u root -p``` - ты это ищешь

# Устновка на mac 

Ну а теперь вы можете одной лишь командой установить вообще всё что угодно в вашу Mac Os в том числе и MySql. Вот так вот просто и быстро:

```bash
brew install mysql
```

Так как сейчас актуальная версия сейчас 8.x, а мне пока что больше по душе 5.7, если вы с числе таких-же ратроградов, вам поможет вот такая команда:

```bash
brew install mysql@5.7
```

Всё наш sql сервер установлен и готов рватся в бой. Давайте теперь немного сконфигурируем его:

Для конфигурации запустите сервер:

```bash
mysql.server start
```

Для подключения 

```bash
mysql -u root
```

Зададим пароль пользователю root

```sql
ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';
```

Если на этом этапе у вас возникнет проблема с тем что терминал не знает команды MySQL выполните линковку с версией 5.7 или той, которую вы выбрали в качестве фаворита

```bash
brew link --force mysql@5.7
```

Для запуска последующего запуска сервера Mysql

```bash
brew services start mysql
```

Для перезапуска 

```bash
brew services restart mysql
```



# 1. Введение 

База данных - структурированный набор постоянно хранимых данных.

В реляционной БД информация хранится в друмерных таблицах.

Строки в таблицах часто называют **записями**

Столбцы часто называют **полями**

Первичный ключ - ID, т.е. уникальное значение для записи в таблице. 

## Когда несколько таблиц

Связь двух таблиц осуществляется через внешний ключ 

<table>
<tbody>
<tr>
<td>id</td>
<td>имя&nbsp;</td>
<td>адрес&nbsp;</td>
</tr>
<tr>
<td>&nbsp;1</td>
<td>Петя&nbsp;</td>
<td>&nbsp;Ленина</td>
</tr>
<tr>
<td>2</td>
<td>Вова</td>
<td>Гагарина</td>
</tr>
<tr>
<td>3</td>
<td>Иван</td>
<td>Гагарина</td>
</tr>
</tbody>
</table>

<table>
<tbody>
<tr>
<td>&nbsp;id</td>
<td>внешний ключ</td>
<td>телефон&nbsp;</td>
<td>тип телефона&nbsp;</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>21324323&nbsp;</td>
<td>&nbsp;домашний</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>12312432</td>
<td>мобильный</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>234235345</td>
<td>мобильный</td>
</tr>
</tbody>
</table>

То есть тут у Вовы два телефона: моб и домашний.

# 2. О SQL

SQL - язык проги для манимулирования и управления БД

**Виды SQL:**

1. **Интерактивный SQL** - используется непосредственно для работы БД;
2. **Статический(вложенный) и динамический SQL** - используется в отдельных программах, которые должны иметь доступ к БД.


**Разделы SQL:**

1. DDL - группа операторов, создающих объекты в базе.
2. DML - группа операторов, управляющих значениями в таблицах.
3. DCL - средства подтверждения прав пользователей на выполение действий.


Типы данных SQL:

- int - целое значение;
- varchar - строки(текст);
- date - даты.


Терминология SQL-команд:

```
SELECT Name, Age, RegDate FROM Clients WHERE Name = "Петр";
```
где **SELECT, FROM, WHERE** - ключевое слово, а **Name, Age** и тп - аргументы.

Сама эта стока - оператор.

Оператор вывоид все строки, где имя равно Петр.

# 3. Запускаем

Cкачали установили все ок.

**Start MySQL**
```bash
sudo /usr/local/mysql/support-files/mysql.server start
```

**Stop MySQL**
```bash
sudo /usr/local/mysql/support-files/mysql.server stop
```

**Restart MySQL**
```bash
sudo /usr/local/mysql/support-files/mysql.server restart
```

<b>Чтобы зайти в консоль mySQL </b>


```bash
mysql -u root -p
```

# 4. Базовые команды

- ```mysql> SHOW databases;``` - показать базы данных;
- ```mysql> CREATE DATABASE test1;``` - создаем таблицу(название не должно иметь пробелов);
- ```mysql> DROP DATABASE new;``` - удалить базу данных;
- ```mysql> USE clients;``` - использовать БД clients. Теперь все действия, которые тут делаются, относятся к этой БД;
- ```mysql> CREATE TABLE people (id INT, fname VARCHAR(30), lname VARCHAR(30), email VARCHAR(30));``` - создать таблицу people c полями. В скобках имя поля, тип данных, органичения (30 символов);
- ```mysql> DROP TABLE people;``` - удалить таблицу из **текущей БД**.
- ```mysql> DESC table_name;``` - показать структуру таблицы table_name;
- ```mysql> INSERT INTO people VALUES (1, 'Petr', 'Radko', 'test@mail.ru');``` - занесение информации в таблицу people. Последовательно указываем значения.
- ```mysql> INSERT INTO subscribers (email, fname) VALUES ('admin@test.com','Vova');``` - если мы хотим в текущую таблицу занести только емаил и имя;
- ```mysql> SELECT * FROM subscribers;``` - показать всю таблицу subscribers;
- ```mysql> SELECT fname, email FROM subscribers;``` - показать только столбцы fname и email из таблицы subscribers;
- ```mysql> RENAME TABLE table_name_before TO table_name_after;``` - переименовать таблицу.
- ```mysql> SHOW TABLES;``` - показать все таблицы БД.


# 5. Подробнее про SELECT

Тестовая таблица.

```
+----------+-------------+-------+------+
| name     | shop_name   | price | rate |
+----------+-------------+-------+------+
| Apple    | Dicsi       |    49 |    7 |
| Pie      | Perekrestok |    76 |    9 |
| Cola     | Dicsi       |    40 |   10 |
| Tomatoes | Dicsi       |    52 |    7 |
| Milk     | Perekrestok |    37 |    8 |
| Melon    | Dicsi       |    40 |    8 |
| Diary    | Dicsi       |    45 |    7 |
+----------+-------------+-------+------+
```

- ```mysql> SELECT name, price FROM products;``` - показать поля name и price из таблицы products;
- ```mysql> SELECT name, price FROM products WHERE rate = 7;``` - показать имя товара и его цену, где рейтинг равен 7. Оператор '<>' означает "не равно";
- ```mysql> SELECT name, price FROM products WHERE shop_name = 'Dicsi' AND rate = 7;``` - показать товары из магазина Дикси c рейтингом 7.
- ```mysql> SELECT name, price FROM products WHERE shop_name = 'Dicsi' OR rate > 8;``` - показать товары из магазина Дикси или рейтингом > 8.
- ```mysql> SELECT name FROM products WHERE shop_name LIKE '%ok'``` - вывести товары, где имя магазина заканчивается на 'ok'. '%' значит любое количество букв.
- ```mysql> SELECT name FROM products WHERE shop_name LIKE 'Dics_';``` - вывести товары, где имя магазина начинается на Disc, **подчеркивание** подразумевает **любую букву**.
- ```mysql> SELECT name FROM products WHERE shop_name LIKE '_ere%' and rate > 7;``` - показать товары, где имя магазина начинается с любой одной буквы, содержит ere и заканчивается любыми буквами И рейтинг > 7.
- ```mysql> SELECT name, rate FROM products WHERE rate IN(7,8,9);``` - показать продукты где рейтинг 7 или 8 или 9.
- ```mysql> SELECT name, rate FROM products WHERE price BETWEEN 50 AND 100;``` - где цена между 50 и 100.
- ```mysql> SELECT name, price FROM products WHERE NOT price  BETWEEN 50 AND 100;``` - где цена не соответствует диапазону между 50 и 100. 
- ```mysql> SELECT name, duration FROM movies WHERE (likes > 100 or dislikes < 100) and dropper <70;``` - хитрое условие.


# 6. Работа с записями

## Удаление записей

```sql
+-------------------------+----------+-------+----------+---------+
| name                    | duration | likes | dislikes | dropper |
+-------------------------+----------+-------+----------+---------+
| Hello World!            |       60 |     3 |       50 |      84 |
| My room                 |      240 |     4 |      192 |      98 |
| How to create minecraft |     1200 |   594 |       13 |      18 |
| CS                      |      360 |    40 |     1200 |      92 |
| Earth                   |     3672 |  5384 |       32 |       9 |
| CMTV Movie              |       60 |   999 |        0 |       0 |
| Just Bad Movie          |       10 |     0 |      100 |     100 |
+-------------------------+----------+-------+----------+---------+
```

- ```mysql> DELETE FROM movies WHERE dropper > 70;``` - удалить все записи из таблицы movies, где dropper >70;

## Обновление записей

- ```mysql> UPDATE movies SET dislikes = 100 WHERE name = 'CMTV Movie';``` - обновить поле dislikes на 100 в записи где имя = CMTV Movies.
- ```mysql> UPDATE movies SET dislikes = dislikes*3; ``` - увеличить все значения dislikes на 3.

# 7. Нормализация (1 форма)

**Нормализованная таблица имеет:**
	
- Атомарность данных (данные столбца должны быть разбиты на наиболее эффективные для нас части)
- Первичный ключ (каждая запись должна иметь свой id)

**Правила атомарности данных**

- **1-е правило атомарности:** столбец не может состоять из нескольких однотипных элементов.
- **2-е правило атомарности:** таблица не может содержать несколько однотипных столбцов. 

## Создание таблицы с первичным ключом

``` mysql> CREATE TABLE products (id INT AUTO_INCREMENT, name VARCHAR(40), price INT, PRIMARY KEY(id)); ``` - где ```AUTO_INCREMENT``` означает автозаполнение id по порядку, а ```PRIMARY KEY(id)``` означает, что поле id будет первичным ключом.

Результат запроса:

```sql
mysql> DESC products;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(11)     | NO   | PRI | NULL    | auto_increment |
| name  | varchar(40) | YES  |     | NULL    |                |
| price | int(11)     | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
3 rows in set (0.02 sec)
```

добавим туда 2 записи и посмотрим результат:

```sql
mysql> INSERT INTO products (name, price) VALUES ('Milk', 49);
...
mysql> INSERT INTO products VALUES (NULL, 'Bread', 16);
...
mysql> SELECT * FROM products;
+----+-------+-------+
| id | name  | price |
+----+-------+-------+
|  1 | Milk  |    49 |
|  2 | Bread |    16 |
+----+-------+-------+
2 rows in set (0.00 sec)

```

Если у нас уже есть таблица и нужно в нее добавить столбец с первичными ключами:

```sql
mysql> SELECT * FROM products;
+----------+-------------+-------+------+
| name     | shop_name   | price | rate |
+----------+-------------+-------+------+
| Apple    | Dicsi       |    49 |    7 |
| Pie      | Perekrestok |    76 |    9 |
| Cola     | Dicsi       |    40 |   10 |
| Tomatoes | Dicsi       |    52 |    7 |
| Milk     | Perekrestok |    37 |    8 |
| Melon    | Dicsi       |    40 |    8 |
| Diary    | Dicsi       |    45 |    7 |
+----------+-------------+-------+------+
7 rows in set (0.01 sec)

mysql> ALTER TABLE products ADD COLUMN id INT AUTO_INCREMENT FIRST, ADD PRIMARY KEY (id);
...

mysql> SELECT * FROM products;

+----+----------+-------------+-------+------+
| id | name     | shop_name   | price | rate |
+----+----------+-------------+-------+------+
|  1 | Apple    | Dicsi       |    49 |    7 |
|  2 | Pie      | Perekrestok |    76 |    9 |
|  3 | Cola     | Dicsi       |    40 |   10 |
|  4 | Tomatoes | Dicsi       |    52 |    7 |
|  5 | Milk     | Perekrestok |    37 |    8 |
|  6 | Melon    | Dicsi       |    40 |    8 |
|  7 | Diary    | Dicsi       |    45 |    7 |
+----+----------+-------------+-------+------+
7 rows in set (0.00 sec)
```

# 8. Изменяем поля - ALTER TABLE

Допустим, есть таблица

```sql
mysql> SELECT * FROM movies;
+-------------------------+----------+-------+----------+---------+
| name                    | duration | likes | dislikes | dropper |
+-------------------------+----------+-------+----------+---------+
| Hello World!            |       60 |     3 |      150 |      84 |
| My room                 |      240 |     4 |      576 |      98 |
| How to create minecraft |     1200 |   594 |       39 |      18 |
| CS                      |      360 |    40 |     3600 |      92 |
| Earth                   |     3672 |  5384 |       96 |       9 |
| CMTV Movie              |       60 |   999 |      300 |       0 |
| Just Bad Movie          |       10 |     0 |      300 |     100 |
+-------------------------+----------+-------+----------+---------+
7 rows in set (0.00 sec)
```
Добавим на первое место поле id.

```sql
mysql> ALTER TABLE movies ADD COLUMN id INT AUTO_INCREMENT FIRST, ADD PRIMARY KEY (id);
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM movies;
+----+-------------------------+----------+-------+----------+---------+
| id | name                    | duration | likes | dislikes | dropper |
+----+-------------------------+----------+-------+----------+---------+
|  1 | Hello World!            |       60 |     3 |      150 |      84 |
|  2 | My room                 |      240 |     4 |      576 |      98 |
|  3 | How to create minecraft |     1200 |   594 |       39 |      18 |
|  4 | CS                      |      360 |    40 |     3600 |      92 |
|  5 | Earth                   |     3672 |  5384 |       96 |       9 |
|  6 | CMTV Movie              |       60 |   999 |      300 |       0 |
|  7 | Just Bad Movie          |       10 |     0 |      300 |     100 |
+----+-------------------------+----------+-------+----------+---------+
7 rows in set (0.00 sec)
```

- ```mysql> ALTER TABLE movies ADD COLUMN test VARCHAR(10) AFTER likes;``` - добавить колонку после поля likes;

- ```mysql> ALTER TABLE movies DROP COLUMN test;``` - удалить поле test в таблице movies;

- ```mysql> ALTER TABLE movies DROP COLUMN test;``` - удалить поле test в таблице movies;

- ```mysql> ALTER TABLE movies RENAME TO test_movies;``` - переименовать таблицу;

- ```mysql> ALTER TABLE movies CHANGE COLUMN name name_list VARCHAR(100) NOT NULL;``` - изменить поле + ограничитель NOT NULL;

- ```mysql> ALTER TABLE movies MODIFY COLUMN name_list VARCHAR(50);``` - изменить только тип поля;
- ```ALTER TABLE movies DROP dislikes, CHANGE name_list name VARCHAR(40);``` - Удалим поле dislikes, и поменям колонку name_list в name.

# 9. Изменяем поля - строковые функции

Функция - блок действий с названием. Функция может производить действия, а также возвращать значения на место вызова.

СТРОКОВЫЕ ФУНКЦИИ:

- RIGHT/LEFT (поле, кол-во символов) - функция возвращает символы в заданном количестве слева/справа от значения в поле;
- SUBSTRING_INDEX (поле, 'разделитель', номер разделителя) - Функция возвращает все символы до разделителя;
- UPPER/LOWER (поле) - в врехний/нижний регистр;
- RTRIM/LTRIM (поле) - убрать пробелы справа/слева.

- ```mysql> SELECT UPPER (name) FROM movies;``` - выводим все значения поля в верхнем регистре (в таблице значения не меняются);

``` mysql> ALTER TABLE movies ADD COLUMN f_name VARCHAR(30), ADD COLUMN l_name VARCHAR(30); ``` - создадим два поля, чтобы разбить имена.

**Пример с разделением имен.**

```sql
mysql> UPDATE movies SET f_name = SUBSTRING_INDEX(name, ' ', 1), l_name = SUBSTRING_INDEX(name, ' ', -1);
mysql> select * from movies;
+----+-------------------------+----------+-------+---------+--------+-----------+
| id | name                    | duration | likes | dropper | f_name | l_name    |
+----+-------------------------+----------+-------+---------+--------+-----------+
|  1 | Hello World!            |       60 |     3 |      84 | Hello  | World!    |
|  2 | My room                 |      240 |     4 |      98 | My     | room      |
|  3 | How to create minecraft |     1200 |   594 |      18 | How    | minecraft |
|  4 | CS                      |      360 |    40 |      92 | CS     | CS        |
|  5 | Earth                   |     3672 |  5384 |       9 | Earth  | Earth     |
|  6 | CMTV Movie              |       60 |   999 |       0 | CMTV   | Movie     |
|  7 | Just Bad Movie          |       10 |     0 |     100 | Just   | Movie     |
+----+-------------------------+----------+-------+---------+--------+-----------+
7 rows in set (0.00 sec)
```

**Пример работы функции RIGHT/LEFT**

```sql
mysql> SELECT RIGHT(name, 2) from movies;
+----------------+
| RIGHT(name, 2) |
+----------------+
| d!             |
| om             |
| ft             |
| CS             |
| th             |
| ie             |
| ie             |
+----------------+
```


# 10. CASE и ORDER BY 

## CASE
Есть таблица:

```sql
+----+-------------+--------------+------------+
| id | fnames_list | lnames_list  | reputation |
+----+-------------+--------------+------------+
|  1 | Peter       | Yan          |        500 |
|  2 | Lola        | Vin          |        324 |
|  3 | Jimmy       | Voode        |         21 |
|  4 | Грег        | Эйтсон       |          0 |
|  5 | Майк        | Гайден       |          2 |
+----+-------------+--------------+------------+
```

Добавим поле rang

```sql
ALTER TABLE users ADD COLUMN rang VARCHAR(20) AFTER reputation;
```

Присвоим записям поля rang значение по условию (это и есть CASE)

```sql

mysql> UPDATE users SET rang = CASE
    -> WHEN reputation > 350 THEN 'Элита'
    -> WHEN reputation > 100 THEN 'популярный'
    -> WHEN reputation > 0 THEN 'Пользователь'
    -> WHEN reputation = 0 THEN 'Новичок'
    -> ELSE 'Нуб'
    -> END;
Query OK, 5 rows affected (0.00 sec)
Rows matched: 5  Changed: 5  Warnings: 0

mysql> SELECT * FROM users;
+----+-------------+--------------+------------+--------------------------+
| id | fnames_list | lnames_list  | reputation | rang                     |
+----+-------------+--------------+------------+--------------------------+
|  1 | Peter       | Yan          |        500 | Элита                    |
|  2 | Lola        | Vin          |        324 | популярный               |
|  3 | Jimmy       | Voode        |         21 | Пользователь             |
|  4 | Грег        | Эйтсон       |          0 | Новичок                  |
|  5 | Майк        | Гайден       |          2 | Пользователь             |
+----+-------------+--------------+------------+--------------------------+
5 rows in set (0.00 sec)
```

## ORDER BY
order by - отсортировать таблицу в алфавитном порядке

Отсортируем по имени.

```sql
mysql> SELECT fnames_list, reputation, rang FROM users ORDER BY fnames_list;
+-------------+------------+--------------------------+
| fnames_list | reputation | rang                     |
+-------------+------------+--------------------------+
| Jimmy       |         21 | Пользователь             |
| Lola        |        324 | популярный               |
| Peter       |        500 | Элита                    |
| Грег        |          0 | Новичок                  |
| Майк        |          2 | Пользователь             |
+-------------+------------+--------------------------+
5 rows in set (0.01 sec)
```
Отсортируем по репутации.

```sql
mysql> SELECT fnames_list, reputation, rang FROM users ORDER BY reputation;
+-------------+------------+--------------------------+
| fnames_list | reputation | rang                     |
+-------------+------------+--------------------------+
| Грег        |          0 | Новичок                  |
| Майк        |          2 | Пользователь             |
| Jimmy       |         21 | Пользователь             |
| Lola        |        324 | популярный               |
| Peter       |        500 | Элита                    |
+-------------+------------+--------------------------+
5 rows in set (0.00 sec)
```

# 11. Функции для работы с числа и еще немного о SELECT

Функции для работы с числами:

- SUM(поле) - выводит сумму;
- MIN/MAX(поле) - выводит минимум/максимум;
- COUNT(поле) - выводит ко-во записей;
- AVG(поле) - выводит среднее арифметическое;

Наша таблица:

```sql
mysql> SELECT * from sales;
+----+----------------+------------------+---------------------------+-------+
| id | fnames_list    | lnames_list      | s_products                | price |
+----+----------------+------------------+---------------------------+-------+
|  1 | Петр           | Радько           | Хлеб                      |    16 |
|  2 | Петр           | Радько           | Нарезной хлеб             |    25 |
|  3 | Петр           | Радько           | Молоко                    |    40 |
|  4 | Николай        | Нивида           | Кола 2л                   |    65 |
|  5 | Николай        | Нивида           | Чипсы                     |    38 |
|  6 | Аня            | Комарова         | Колбаса                   |    42 |
|  7 | Аня            | Комарова         | Арбуз                     |    70 |
|  8 | Аня            | Комарова         | Торт                      |   120 |
|  9 | Аня            | Комарова         | Жвачка                    |    22 |
+----+----------------+------------------+---------------------------+-------+
```

```sql
mysql> SELECT SUM(price) FROM sales;;
+------------+
| SUM(price) |
+------------+
|        438 |
+------------+
1 row in set (0.00 sec)
```

Кто купил самый дорогой товар.

```sql
mysql> SELECT fnames_list, lnames_list, s_products FROM sales WHERE price = (SELECT MAX(price) FROM sales);
+-------------+------------------+------------+
| fnames_list | lnames_list      | s_products |
+-------------+------------------+------------+
| Аня         | Комарова         | Торт       |
+-------------+------------------+------------+
```

Вывести в обратном порядке (DESC)

```sql
mysql> SELECT fnames_list, lnames_list, s_products, price FROM sales ORDER BY price DESC;
+----------------+------------------+---------------------------+-------+
| fnames_list    | lnames_list      | s_products                | price |
+----------------+------------------+---------------------------+-------+
| Аня            | Комарова         | Торт                      |   120 |
| Аня            | Комарова         | Арбуз                     |    70 |
| Николай        | Нивида           | Кола 2л                   |    65 |
| Аня            | Комарова         | Колбаса                   |    42 |
| Петр           | Радько           | Молоко                    |    40 |
| Николай        | Нивида           | Чипсы                     |    38 |
| Петр           | Радько           | Нарезной хлеб             |    25 |
| Аня            | Комарова         | Жвачка                    |    22 |
| Петр           | Радько           | Хлеб                      |    16 |
+----------------+------------------+---------------------------+-------+
```

Вывести в алфавитном порядке (ASC):

```sql
mysql> SELECT fnames_list, lnames_list, s_products, price FROM sales ORDER BY price ASC;
+----------------+------------------+---------------------------+-------+
| fnames_list    | lnames_list      | s_products                | price |
+----------------+------------------+---------------------------+-------+
| Петр           | Радько           | Хлеб                      |    16 |
| Аня            | Комарова         | Жвачка                    |    22 |
| Петр           | Радько           | Нарезной хлеб             |    25 |
| Николай        | Нивида           | Чипсы                     |    38 |
| Петр           | Радько           | Молоко                    |    40 |
| Аня            | Комарова         | Колбаса                   |    42 |
| Николай        | Нивида           | Кола 2л                   |    65 |
| Аня            | Комарова         | Арбуз                     |    70 |
| Аня            | Комарова         | Торт                      |   120 |
+----------------+------------------+---------------------------+-------+
9 rows in set (0.00 sec)
```

Выведем среднюю цену:

```sql
mysql> SELECT AVG(price) from sales;
+------------+
| AVG(price) |
+------------+
|    48.6667 |
+------------+
1 row in set (0.00 sec)
```

Сколько каждый покупатель потратил денег:

```
mysql> SELECT fnames_list, SUM(price) FROM sales GROUP BY fnames_list;
+----------------+------------+
| fnames_list    | SUM(price) |
+----------------+------------+
| Петр           |         81 |
| Николай        |        103 |
| Аня            |        254 |
+----------------+------------+
3 rows in set (0.01 sec)
```

Самая дорогая покупка каждого покупателя;

```
mysql> SELECT fnames_list, MAX(price) FROM sales GROUP BY fnames_list;
+----------------+------------+
| fnames_list    | MAX(price) |
+----------------+------------+
| Петр           |         40 |
| Николай        |         65 |
| Аня            |        120 |
+----------------+------------+
3 rows in set (0.00 sec)
```

## SELECT DISTINCT
distinct - создает вывод без дубликатов;

```
mysql> SELECT DISTINCT fnames_list from sales;
+----------------+
| fnames_list    |
+----------------+
| Петр           |
| Николай        |
| Аня            |
+----------------+
3 rows in set (0.00 sec)
```

## SELECT ... LIMIT
LIMIT - выводит топ по какому-либо признаку.

Вывести 2 самые дорогие покупки.

```
mysql> SELECT fnames_list, s_products, price FROM sales ORDER BY price DESC LIMIT 2;
+-------------+------------+-------+
| fnames_list | s_products | price |
+-------------+------------+-------+
| Аня         | Торт       |   120 |
| Аня         | Арбуз      |    70 |
+-------------+------------+-------+
2 rows in set (0.00 sec)
```

Выбрать 3 элемента от 1-го товара (НЕ С ОДНОГО ДО ТРЕХ):

```
mysql> SELECT fnames_list, s_products, price FROM sales ORDER BY price DESC LIMIT 1,3;
+----------------+----------------+-------+
| fnames_list    | s_products     | price |
+----------------+----------------+-------+
| Аня            | Арбуз          |    70 |
| Николай        | Кола 2л        |    65 |
| Аня            | Колбаса        |    42 |
+----------------+----------------+-------+
3 rows in set (0.00 sec)
```

# 12. Полезные фишки

1. SELECT поле AS псевдоним...;
2. CREATE... имя поля... DEFAULT значение...;
3. INSERT INTO таблица VALUES(,.....);


DEFAULT

```ALTER TABLE users_12 ADD COLUMN income INT DEFAULT 0;``` - добавить колонку и установить незаполненным полям 0 по умолчанию.


# 13. Внешний вид и виды связей

Допустим, есть таблица с первичным ключом ```user_id```

```
+---------+------------+
| user_id | name       |
+---------+------------+
|       1 | Петр       |
|       2 | Женя       |
|       3 | Коля       |
|       4 | Игорь      |
+---------+------------+
4 rows in set (0.00 sec)

```

Создаем ВНЕШНЮЮ таблицу

```
mysql> CREATE TABLE activities (
	-> activity_id INT AUTO_INCREMENT PRIMARY KEY,
	-> activity VARCHAR(20) NOT NULL,
	-> user_id INT,
	-> FOREIGN KEY(user_id) REFERENCES contacts(user_id));
Query OK, 0 rows affected (0.02 sec)
```
, где ```FOREIGN KEY(user_id)``` - поле в новой таблице, которое будет ссылаться на другую таблицу с ключом.

Добавим запись в новую таблицу, используя подзапрос:

```
mysql> desc activities;
+-------------+-------------+------+-----+---------+----------------+
| Field       | Type        | Null | Key | Default | Extra          |
+-------------+-------------+------+-----+---------+----------------+
| activity_id | int(11)     | NO   | PRI | NULL    | auto_increment |
| activity    | varchar(20) | NO   |     | NULL    |                |
| user_id     | int(11)     | YES  | MUL | NULL    |                |
+-------------+-------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

mysql> insert into activities VALUES (NULL, 'собаки', (SELECT user_id FROM contacts WHERE name = 'Петр'));
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM ACTIVITIES;
+-------------+--------------+---------+
| activity_id | activity     | user_id |
+-------------+--------------+---------+
|           1 | собаки       |       1 |
+-------------+--------------+---------+
1 row in set (0.00 sec)
```

## 13.1 Типы связей между полями разных таблиц

1. Один к одному;
2. Один ко многим;
3. Многие ко многим.


### 13.1.1 Создание связи один к одному

Для таблицы persons:

```
mysql> SELECT * FROM persons;
+-----------+----------------+
| person_id | name           |
+-----------+----------------+
|         1 | Петр           |
|         2 | Николай        |
|         3 | Роман          |
+-----------+----------------+
3 rows in set (0.00 sec)
```

Создадим связь 1 к 1:

```
mysql> CREATE TABLE locations (
    -> person_location_id INT NOT NULL PRIMARY KEY,
    -> name VARCHAR(20),
    -> FOREIGN KEY (person_location_id) REFERENCES persons (person_id));
Query OK, 0 rows affected (0.01 sec)
```

Готово:

```
mysql> SELECT * FROM persons;
+-----------+----------------+
| person_id | name           |
+-----------+----------------+
|         1 | Петр           |
|         2 | Николай        |
|         3 | Роман          |
+-----------+----------------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM locations;
+--------------------+------------------+
| person_location_id | name             |
+--------------------+------------------+
|                  1 | Москва           |
|                  2 | Лондон           |
|                  3 | Новгород         |
+--------------------+------------------+
3 rows in set (0.00 sec)
```
### 13.1.2 Создание связи один ко многим

Создадим табллицы:

```
mysql> SELECT * FROM users;
+---------+-----------+---------------+
| user_id | user_name | profession_id |
+---------+-----------+---------------+
|       1 | Петр      |          NULL |
|       2 | Женя      |          NULL |
|       3 | Коля      |          NULL |
+---------+-----------+---------------+
3 rows in set (0.00 sec)
```

Создадим вторую таблицу и свяжем ее с первой:

```
mysql> ALTER TABLE users ADD FOREIGN KEY (profession_id) REFERENCES professions(profession_id);
Query OK, 3 rows affected (0.03 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM users;
+---------+-----------+---------------+
| user_id | user_name | profession_id |
+---------+-----------+---------------+
|       1 | Петр      |          NULL |
|       2 | Женя      |          NULL |
|       3 | Коля      |          NULL |
+---------+-----------+---------------+
3 rows in set (0.00 sec)
```

Обновим связи по условию и получим связь 1 ко многим:

```
mysql> UPDATE users
    -> SET profession_id = 1
    -> WHERE user_name IN ('Женя', 'Коля');
Query OK, 2 rows affected (0.01 sec)
Rows matched: 2  Changed: 2  Warnings: 0

mysql> SELECT * FROM users;
+---------+-----------+---------------+
| user_id | user_name | profession_id |
+---------+-----------+---------------+
|       1 | Петр      |          NULL |
|       2 | Женя      |             1 |
|       3 | Коля      |             1 |
+---------+-----------+---------------+
3 rows in set (0.00 sec)
```

### 13.1.3 Создание связи многие ко многим

*Напряму нельзя реализовать связь "многие ко многим". Нужно создать соединительную таблицу.

Выведем текущие таблицы и создадим для них соединительную таблицу.

```
mysql> SELECT * FROM students;
+------------+--------------+
| student_id | student_name |
+------------+--------------+
|          1 | Петр         |
|          2 | Женя         |
|          3 | Коля         |
+------------+--------------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM classes;
+----------+------------+
| class_id | class_name |
+----------+------------+
|        1 | 1B         |
|        2 | 2B         |
|        3 | 1A         |
+----------+------------+
3 rows in set (0.00 sec)

mysql> CREATE TABLE students_classes (
    -> student_id INT NOT NULL,
    -> class_id INT NOT NULL,
    -> PRIMARY KEY (student_id, class_id),
    -> FOREIGN KEY (student_id) REFERENCES students (student_id),
    -> FOREIGN KEY (class_id) REFERENCES classes (class_id));
Query OK, 0 rows affected (0.02 sec)
```

Заполним и выведем таблицу со связями многие ко многим;

```
mysql> INSERT INTO students_classes VALUES(1,1);
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO students_classes VALUES(1,2);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO students_classes VALUES(1,3);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO students_classes VALUES(2,1);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO students_classes VALUES(2,2);
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO students_classes VALUES(2,3);
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM students_classes;
+------------+----------+
| student_id | class_id |
+------------+----------+
|          1 |        1 |
|          2 |        1 |
|          1 |        2 |
|          2 |        2 |
|          1 |        3 |
|          2 |        3 |
+------------+----------+
6 rows in set (0.00 sec)
```

# 14. Соединения

Соединения используются, чтобы выводить информацию из двух таблиц.

- ```поле INNER JOIN поле ON условия``` - внутреннее соединение;
- ```поле CROSS JOIN поле``` - перекрестное соединение;
- ```поле NATURAL JOIN``` - естественное соединение;
- ```поле LEFT JOIN поле ON``` - левое внешнее соединение;
- ```поле RIGHT JOIN поле ON``` - правое внешнее соединение.

Есть две связанные таблицы:

```
mysql> SELECT * FROM books;
+---------+-----------------------------------------+--------------+
| book_id | book_name                               | publisher_id |
+---------+-----------------------------------------+--------------+
|       1 | Магия и кровь                           |            3 |
|       2 | Уникальная вселенная                    |            2 |
|       3 | Физика                                  |         NULL |
|       4 | Рассказ о цветах                        |            1 |
+---------+-----------------------------------------+--------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM publishers;
+--------------+---------------------------+
| publisher_id | publisher_name            |
+--------------+---------------------------+
|            1 | Все книги                 |
|            2 | Прокачай моск             |
|            3 | Мир фантазии              |
+--------------+---------------------------+
3 rows in set (0.00 sec)
```

## 14.1 Перекрестное соединение (CROSS JOIN)

```
mysql> SELECT b.book_name, p.publisher_name FROM books b CROSS JOIN publishers p;
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Магия и кровь                           | Все книги                 |
| Магия и кровь                           | Прокачай моск             |
| Магия и кровь                           | Мир фантазии              |
| Уникальная вселенная                    | Все книги                 |
| Уникальная вселенная                    | Прокачай моск             |
| Уникальная вселенная                    | Мир фантазии              |
| Физика                                  | Все книги                 |
| Физика                                  | Прокачай моск             |
| Физика                                  | Мир фантазии              |
| Рассказ о цветах                        | Все книги                 |
| Рассказ о цветах                        | Прокачай моск             |
| Рассказ о цветах                        | Мир фантазии              |
+-----------------------------------------+---------------------------+
12 rows in set (0.00 sec)
```


## 14.2 Естественное соединение (NATURAL JOIN)

```
mysql> SELECT b.book_name, p.publisher_name FROM books b NATURAL JOIN publishers p;
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Рассказ о цветах                        | Все книги                 |
| Уникальная вселенная                    | Прокачай моск             |
| Магия и кровь                           | Мир фантазии              |
+-----------------------------------------+---------------------------+
3 rows in set (0.00 sec)
```

## 14.3 Внутреннее соединение (INNER JOIN)

**Эквивалентные соединения**

```
mysql> SELECT b.book_name, p.publisher_name FROM books b INNER JOIN publishers p
    -> ON b.publisher_id = p.publisher_id;
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Рассказ о цветах                        | Все книги                 |
| Уникальная вселенная                    | Прокачай моск             |
| Магия и кровь                           | Мир фантазии              |
+-----------------------------------------+---------------------------+
3 rows in set (0.00 sec)
```

**Неэквивалентные соединения**

```
mysql> SELECT b.book_name, p.publisher_name FROM books b INNER JOIN publishers p
	-> ON b.publisher_id <> p.publisher_id;
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Магия и кровь                           | Все книги                 |
| Магия и кровь                           | Прокачай моск             |
| Уникальная вселенная                    | Все книги                 |
| Уникальная вселенная                    | Мир фантазии              |
| Рассказ о цветах                        | Прокачай моск             |
| Рассказ о цветах                        | Мир фантазии              |
+-----------------------------------------+---------------------------+
6 rows in set (0.00 sec)
```

## 14.4 Внешнее левое соединения (LEFT JOIN)

```
mysql> SELECT books.book_name, publishers.publisher_name
	-> FROM books LEFT JOIN publishers USING (publisher_id);
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Рассказ о цветах                        | Все книги                 |
| Уникальная вселенная                    | Прокачай моск             |
| Магия и кровь                           | Мир фантазии              |
| Физика                                  | NULL                      |
+-----------------------------------------+---------------------------+
4 rows in set (0.01 sec)
```

Вывести только те записи из books, где NULL.

```
mysql> SELECT books.book_name, publishers.publisher_name
	-> FROM books LEFT JOIN publishers
	-> ON books.publisher_id = publishers.publisher_id
	-> WHERE books.publisher_id IS NULL;
+--------------+----------------+
| book_name    | publisher_name |
+--------------+----------------+
| Физика       | NULL           |
+--------------+----------------+
1 row in set (0.01 sec)

```

## 14.5 Внешнее правое соединения (RIGHT JOIN)


```
mysql> SELECT books.book_name, publishers.publisher_name
	-> FROM books RIGHT JOIN publishers USING (publisher_id);
+-----------------------------------------+---------------------------+
| book_name                               | publisher_name            |
+-----------------------------------------+---------------------------+
| Рассказ о цветах                        | Все книги                 |
| Уникальная вселенная                    | Прокачай моск             |
| Магия и кровь                           | Мир фантазии              |
+-----------------------------------------+---------------------------+
3 rows in set (0.00 sec)

```



# 15. Еще фишки и подзапросы

Подзапрос - это когда мы должны получить какой-то вывод внутри уже существующиего запроса

В большинстве случаев подзопрос должен вернуть одно значение

```
mysql> INSERT INTO reviews values ((SELECT book_id
	 -> FROM books WHERE book_name = 'Магия и кровь'),
    -> 8, 'Сочные битвы и хороший сюжет');
Query OK, 1 row affected (0.01 sec)

```

# 16. Нормальные формы

Нормальная форма - изменение данных таблиц, чтобы

НОрмальных форм 7 (но рассматриваем тут 3)

1 НФ - Все данные атомарны;
2 НФ - Отсутствие частничных функциональных зависимостей (когда есть составной первичный ключ и какое-то поле не ключевое зависит от какой-то части этого ключа). В таких случаях лучше создать отдельную таблицу и привязать к id то поле.
2 НФ - Отсутствие транзитивных функциональных заввисимостей. Когда неключевое поле зависит от другого неключевого поля.

Не нужно добавлять однотипные поля в таблицу. Лучше сделать отдельную таблицу.

Составной первичный ключ - когда два и более полей выступают как ключ.

# 17. Представления

Создадим 1-ю таблицу для начала

```
mysql> CREATE TABLE users (
	-> id INT AUTO_INCREMENT PRIMARY KEY,
	-> fname VARCHAR(20) NOT NULL,
	-> lname VARCHAR(20),
	-> email VARCHAR(30) NOT NULL UNIQUE);

mysql> CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, fname VARCHAR(20) NOT NULL, lname VARCHAR(20), email VARCHAR(30) NOT NULL UNIQUE);
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO users VALUES(NULL, 'Петр', 'Радько', 'test@mail.ru');
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO users VALUES(NULL, 'Роман', 'Поаов', 'romb@mail.ru');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO users VALUES(NULL, 'Увгений', 'Оливье', 'zheka@mail.ru');
Query OK, 1 row affected (0.01 sec)
```

Создадим вторую табл

```
mysql> CREATE TABLE provate_inf (
    -> id INT PRIMARY KEY,
    -> income INT NOT NULL DEFAULT 0,
    -> FOREIGN KEY (id) REFERENCES users(id));
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO provate_inf VALUES (1, 20000);
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO provate_inf VALUES (2, 20000);
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO provate_inf VALUES (3, 1000);
Query OK, 1 row affected (0.01 sec)


```

Соединим и по условию выведем инфу

```
mysql> select u.fname, u.lname, p.income
	-> FROM users u INNER JOIN provate_inf p
	-> ON u.id = p.id
	-> WHERE p.income > (SELECT AVG(income)
	-> FROM provate_inf);
+------------+--------------+--------+
| fname      | lname        | income |
+------------+--------------+--------+
| Петр       | Радько       |  20000 |
| Роман      | Поаов        |  20000 |
+------------+--------------+--------+
2 rows in set (0.01 sec)
```


Если нам по 10 раз необходимо выводить эту инфу, используем представления.

Как превратить сложный запрос в простую команду, спользуя VIEW

```
mysql> CREATE VIEW maxIncome as select u.fname, u.lname, p.income
	-> FROM users u INNER JOIN provate_inf p ON u.id = p.id
	-> WHERE p.income > (SELECT AVG(income)
	-> FROM provate_inf);
Query OK, 0 rows affected (0.01 sec)
```

Заюзаем команду

```
mysql> SELECT * FROM maxIncome;
+------------+--------------+--------+
| fname      | lname        | income |
+------------+--------------+--------+
| Петр       | Радько       |  20000 |
| Роман      | Поаов        |  20000 |
+------------+--------------+--------+
2 rows in set (0.00 sec)
```

Удалим команду

```
mysql> DROP VIEW maxIncome;
Query OK, 0 rows affected (0.01 sec)
```
